{'AdaptSigma': 'True  # or False or any CMAAdaptSigmaBase class e.g. CMAAdaptSigmaTPA, CMAAdaptSigmaCSA', 'CMA_active': 'True  # negative update, conducted after the original update', 'CMA_cmean': '1  # learning rate for the mean value', 'CMA_const_trace': 'False  # normalize trace, value CMA_const_trace=2 normalizes sum log eigenvalues to zero', 'CMA_diagonal': '0*100*N/popsize**0.5  # nb of iterations with diagonal covariance matrix, True for always', 'CMA_eigenmethod': 'np.linalg.eigh  # or cma.utils.eig or pygsl.eigen.eigenvectors', 'CMA_elitist': 'False  #v or "initial" or True, elitism likely impairs global search performance', 'CMA_mirrors': 'popsize < 6  # values <0.5 are interpreted as fraction, values >1 as numbers (rounded), otherwise about 0.16 is used', 'CMA_mirrormethod': '2  # 0=unconditional, 1=selective, 2=selective with delay', 'CMA_mu': 'None  # parents selection parameter, default is popsize // 2', 'CMA_on': '1  # multiplier for all covariance matrix updates', 'CMA_sample_on_sphere_surface': 'False  #v all mutation vectors have the same length, currently (with new_sampling) not in effect', 'CMA_sampler': 'None  # a class or instance that implements the interface of `cma.interfaces.StatisticalModelSamplerWithZeroMeanBaseClass`', 'CMA_sampler_options': '{}  # options passed to `CMA_sampler` class init as keyword arguments', 'CMA_rankmu': '1.0  # multiplier for rank-mu update learning rate of covariance matrix', 'CMA_rankone': '1.0  # multiplier for rank-one update learning rate of covariance matrix', 'CMA_recombination_weights': 'None  # a list, see class RecombinationWeights, overwrites CMA_mu and popsize options', 'CMA_dampsvec_fac': 'np.Inf  # tentative and subject to changes, 0.5 would be a "default" damping for sigma vector update', 'CMA_dampsvec_fade': '0.1  # tentative fading out parameter for sigma vector update', 'CMA_teststds': 'None  # factors for non-isotropic initial distr. of C, mainly for test purpose, see CMA_stds for production', 'CMA_stds': 'None  # multipliers for sigma0 in each coordinate, not represented in C, makes scaling_of_variables obsolete', 'CSA_dampfac': '1  #v positive multiplier for step-size damping, 0.3 is close to optimal on the sphere', 'CSA_damp_mueff_exponent': '0.5  # zero would mean no dependency of damping on mueff, useful with CSA_disregard_length option', 'CSA_disregard_length': 'False  #v True is untested', 'CSA_clip_length_value': 'None  #v untested, [0, 0] means disregarding length completely', 'CSA_squared': 'False  #v use squared length for sigma-adaptation ', 'BoundaryHandler': 'BoundTransform  # or BoundPenalty, unused when ``bounds in (None, [None, None])``', 'bounds': '[None, None]  # lower (=bounds[0]) and upper domain boundaries, each a scalar or a list/vector', 'fixed_variables': 'None  # dictionary with index-value pairs like {0:1.1, 2:0.1} that are not optimized', 'ftarget': '-inf  #v target function value, minimization', 'integer_variables': '[]  # index list, invokes basic integer handling: prevent std dev to become too small in the given variables', 'is_feasible': 'is_feasible  #v a function that computes feasibility, by default lambda x, f: f not in (None, np.NaN)', 'maxfevals': 'inf  #v maximum number of function evaluations', 'maxiter': '100 + 150 * (N+3)**2 // popsize**0.5  #v maximum number of iterations', 'mean_shift_line_samples': 'False #v sample two new solutions colinear to previous mean shift', 'mindx': '0  #v minimal std in any arbitrary direction, cave interference with tol*', 'minstd': '0  #v minimal std (scalar or vector) in any coordinate direction, cave interference with tol*', 'maxstd': 'inf  #v maximal std in any coordinate direction', 'pc_line_samples': 'False #v one line sample along the evolution path pc', 'popsize': '4+int(3*np.log(N))  # population size, AKA lambda, number of new solution per iteration', 'randn': 'np.random.randn  #v randn(lam, N) must return an np.array of shape (lam, N)', 'scaling_of_variables': 'None  # depreciated, rather use fitness_transformations.ScaleCoordinates instead (or possibly CMA_stds).\n            Scale for each variable in that effective_sigma0 = sigma0*scaling. Internally the variables are divided by scaling_of_variables and sigma is unchanged, default is `np.ones(N)`', 'seed': 'None  # random number seed', 'signals_filename': 'None  # cma_signals.in  # read versatile options from this file which contains a single options dict, e.g. ``{"timeout": 0}`` to stop, string-values are evaluated, e.g. "np.inf" is valid', 'termination_callback': 'None  #v a function returning True for termination, called in `stop` with `self` as argument, could be abused for side effects', 'timeout': 'inf  #v stop if timeout seconds are exceeded, the string "2.5 * 60**2" evaluates to 2 hours and 30 minutes', 'tolconditioncov': '1e14  #v stop if the condition of the covariance matrix is above `tolconditioncov`', 'tolfacupx': '1e3  #v termination when step-size increases by tolfacupx (diverges). That is, the initial step-size was chosen far too small and better solutions were found far away from the initial solution x0', 'tolupsigma': '1e20  #v sigma/sigma0 > tolupsigma * max(eivenvals(C)**0.5) indicates "creeping behavior" with usually minor improvements', 'tolfun': '1e-11  #v termination criterion: tolerance in function value, quite useful', 'tolfunhist': '1e-12  #v termination criterion: tolerance in function value history', 'tolstagnation': 'int(100 + 100 * N**1.5 / popsize)  #v termination if no improvement over tolstagnation iterations', 'tolx': '1e-11  #v termination criterion: tolerance in x-changes', 'transformation': 'None  # depreciated, use cma.fitness_transformations.FitnessTransformation instead.\n            [t0, t1] are two mappings, t0 transforms solutions from CMA-representation to f-representation (tf_pheno),\n            t1 is the (optional) back transformation, see class GenoPheno', 'typical_x': 'None  # used with scaling_of_variables', 'updatecovwait': 'None  #v number of iterations without distribution update, name is subject to future changes', 'verbose': '3  #v verbosity e.v. of initial/final message, -1 is very quiet, -9 maximally quiet, not yet fully implemented', 'verb_append': '0  # initial evaluation counter, if append, do not overwrite output files', 'verb_disp': '100  #v verbosity: display console output every verb_disp iteration', 'verb_filenameprefix': 'outcmaes  # output filenames prefix', 'verb_log': '1  #v verbosity: write data to files every verb_log iteration, writing can be time critical on fast to evaluate functions', 'verb_plot': '0  #v in fmin(): plot() is called every verb_plot iteration', 'verb_time': 'True  #v output timings on console', 'vv': '0  #? versatile variable for hacking purposes, value found in self.opts["vv"]'}
